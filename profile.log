SCRIPT  C:\Program Files\Neovim\share\nvim\runtime\ftplugin\lua.vim
Sourced 1 time
Total time:   0.000292
 Self time:   0.000292

count  total (s)   self (s)
                            " Vim filetype plugin file.
                            " Language:		Lua
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Previous Maintainer:	Max Ischenko <mfi@ukr.net>
                            " Contributor:		Dorai Sitaram <ds26@gte.com>
                            "			C.D. MacEachern <craig.daniel.maceachern@gmail.com>
                            "			Phạm Bình An <phambinhanctb2004@gmail.com>
                            " Last Change:		2025 Feb 27
                            
    1              0.000015 if exists("b:did_ftplugin")
                              finish
    1              0.000002 endif
    1              0.000006 let b:did_ftplugin = 1
                            
                            " keep in sync with syntax/lua.vim
    1              0.000004 if !exists("lua_version")
                              " Default is lua 5.3
    1              0.000006   let lua_version = 5
    1              0.000003   let lua_subversion = 3
                            elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. In this case set it to 0
                              let lua_subversion = 0
    1              0.000001 endif
                            
    1              0.000005 let s:cpo_save = &cpo
    1              0.000012 set cpo&vim
                            
    1              0.000009 setlocal comments=:---,:--
    1              0.000005 setlocal commentstring=--\ %s
    1              0.000009 setlocal formatoptions-=t formatoptions+=croql
                            
    1              0.000007 let &l:define = '\<function\|\<local\%(\s\+function\)\='
                            
    1              0.000005 let &l:include = '\<\%(\%(do\|load\)file\|require\)\s*('
    1              0.000009 setlocal includeexpr=s:LuaInclude(v:fname)
    1              0.000004 setlocal suffixesadd=.lua
                            
    1              0.000003 let b:undo_ftplugin = "setl cms< com< def< fo< inc< inex< sua<"
                            
    1              0.000006 if exists("loaded_matchit") && !exists("b:match_words")
    1              0.000003   let b:match_ignorecase = 0
    1              0.000010   let b:match_words =
                            	\ '\<\%(do\|function\|if\)\>:' ..
                            	\ '\<\%(return\|else\|elseif\)\>:' ..
                            	\ '\<end\>,' ..
                            	\ '\<repeat\>:\<until\>,' ..
                            	\ '\%(--\)\=\[\(=*\)\[:]\1]'
    1              0.000005   let b:undo_ftplugin ..= " | unlet! b:match_words b:match_ignorecase"
    1              0.000001 endif
                            
    1              0.000018 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              let b:browsefilter = "Lua Source Files (*.lua)\t*.lua\n"
                              if has("win32")
                                let b:browsefilter ..= "All Files (*.*)\t*\n"
                              else
                                let b:browsefilter ..= "All Files (*)\t*\n"
                              endif
                              let b:undo_ftplugin ..= " | unlet! b:browsefilter"
    1              0.000001 endif
                            
                            " The rest of the file needs to be :sourced only once per Vim session
    1              0.000004 if exists("s:loaded_lua") || &cp
                              let &cpo = s:cpo_save
                              unlet s:cpo_save
                              finish
    1              0.000001 endif
    1              0.000002 let s:loaded_lua = 1
                            
    1              0.000006 function s:LuaInclude(fname) abort
                              let lua_ver = str2float(printf("%d.%02d", g:lua_version, g:lua_subversion))
                              let fname = tr(a:fname, '.', '/')
                              let paths = lua_ver >= 5.03 ? [fname .. ".lua", fname .. "/init.lua"] : [fname .. ".lua"]
                              for path in paths
                                if filereadable(path)
                                  return path
                                endif
                              endfor
                              return fname
                            endfunction
                            
    1              0.000007 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: nowrap sw=2 sts=2 ts=8 noet:

SCRIPT  C:\Program Files\Neovim\share\nvim\runtime\ftplugin\lua.lua
Sourced 1 time
Total time:   0.021093
 Self time:   0.020836

count  total (s)   self (s)
                            -- use treesitter over syntax
                            vim.treesitter.start()
                            
                            vim.bo.includeexpr = [[v:lua.require'vim._ftplugin.lua'.includeexpr(v:fname)]]
                            vim.bo.omnifunc = 'v:lua.vim.lua_omnifunc'
                            vim.wo[0][0].foldexpr = 'v:lua.vim.treesitter.foldexpr()'
                            
                            vim.b.undo_ftplugin = (vim.b.undo_ftplugin or '')
                              .. '\n call v:lua.vim.treesitter.stop()'
                              .. '\n setl omnifunc< foldexpr< includeexpr<'

SCRIPT  C:\Program Files\Neovim\share\nvim\runtime\indent\lua.vim
Sourced 1 time
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Lua script
                            " Maintainer:	Marcus Aurelius Farias <marcus.cf 'at' bol.com.br>
                            " First Author:	Max Ischenko <mfi 'at' ukr.net>
                            " Last Change:	2017 Jun 13
                            "		2022 Sep 07: b:undo_indent added by Doug Kearns
                            "		2024 Jul 27: by Vim project: match '(', ')' in function GetLuaIndentIntern()
                            
                            " Only load this indent file when no other was loaded.
    1              0.000006 if exists("b:did_indent")
                              finish
    1              0.000001 endif
    1              0.000003 let b:did_indent = 1
                            
    1              0.000007 setlocal indentexpr=GetLuaIndent()
                            
                            " To make Vim call GetLuaIndent() when it finds '\s*end' or '\s*until'
                            " on the current line ('else' is default and includes 'elseif').
    1              0.000004 setlocal indentkeys+=0=end,0=until
                            
    1              0.000002 setlocal autoindent
                            
    1              0.000002 let b:undo_indent = "setlocal autoindent< indentexpr< indentkeys<"
                            
                            " Only define the function once.
    1              0.000003 if exists("*GetLuaIndent")
                              finish
    1              0.000000 endif
                            
    1              0.000002 function! GetLuaIndent()
                                let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetLuaIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunction
                            
    1              0.000001 function! GetLuaIndentIntern()
                              " Find a non-blank line above the current line.
                              let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
                              if prevlnum == 0
                                return 0
                              endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{', '('
                              let ind = indent(prevlnum)
                              let prevline = getline(prevlnum)
                              let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
                              if midx == -1
                                let midx = match(prevline, '\%({\|(\)\s*\%(--\%([^[].*\)\?\)\?$')
                                if midx == -1
                                  let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
                                endif
                              endif
                            
                              if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
                                if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
                                  let ind = ind + shiftwidth()
                                endif
                              endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until, '}' and ')'
                              " This is the part that requires 'indentkeys'.
                              let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\|)\)')
                              if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction

FUNCTION  <SNR>42_Highlight_Matching_Pair()
    Defined: C:\Program Files\Neovim\share/nvim/runtime/plugin/matchparen.vim:45
Called 52 times
Total time:   0.015428
 Self time:   0.014368

count  total (s)   self (s)
   52              0.000518   if !exists("w:matchparen_ids")
    1              0.000001     let w:matchparen_ids = []
   52              0.000073   endif
                              " Remove any previous match.
   52   0.001604   0.000544   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   52              0.000353   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   52              0.000028   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   52              0.000221   let c_lnum = line('.')
   52              0.000143   let c_col = col('.')
   52              0.000070   let before = 0
                            
   52              0.000190   let text = getline(c_lnum)
   52              0.000413   let c_before = text->strpart(0, c_col - 1)->slice(-1)
   52              0.000237   let c = text->strpart(c_col - 1)->slice(0, 1)
   52              0.001235   let plist = split(&matchpairs, '.\zs[:,]')
   52              0.000209   let i = index(plist, c)
   52              0.000073   if i < 0
                                " not found, in Insert mode try character before the cursor
   47              0.000169     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
   47              0.000033     endif
   47              0.000050     if i < 0
                                  " not found, nothing to do
   47              0.000054       return
                                endif
    5              0.000003   endif
                            
                              " Figure out the arguments for searchpairpos().
    5              0.000007   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
    5              0.000004   else
    5              0.000008     let s_flags = 'nbW'
    5              0.000008     let c2 = c
    5              0.000015     let c = plist[i - 1]
    5              0.000003   endif
    5              0.000008   if c == '['
                                let c = '\['
                                let c2 = '\]'
    5              0.000003   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    5              0.000006   if before > 0
                                let save_cursor = getcurpos()
                                call cursor(c_lnum, c_col - before)
                                defer setpos('.', save_cursor)
    5              0.000002   endif
                            
    5              0.000044   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    5              0.000025   elseif exists("b:ts_highlight") && &syntax != 'on'
    5              0.000029     let s_skip = "match(v:lua.vim.treesitter.get_captures_at_cursor(), '" .. 'string\|character\|singlequote\|escape\|symbol\|comment' .. "') != -1"
                              else
                                " do not attempt to match when the syntax item where the cursor is
                                " indicates there does not exist a matching parenthesis, e.g. for shells
                                " case statement: "case $var in foobar)"
                                "
                                " add the check behind a filetype check, so it only needs to be
                                " evaluated for certain filetypes
                                if ['sh']->index(&filetype) >= 0 && synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "shSnglCase"}) >= 0
                                  return
                                endif
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
    5              0.000003   endif
                            
                              " Limit the search to lines visible in the window.
    5              0.000026   let stoplinebottom = line('w$')
    5              0.000011   let stoplinetop = line('w0')
    5              0.000006   if i % 2 == 0
                                let stopline = stoplinebottom
    5              0.000003   else
    5              0.000010     let stopline = stoplinetop
    5              0.000003   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    5              0.000017   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    5              0.000003   else
    5              0.000030     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    5              0.000002   endif
    5              0.000004   try
    5              0.007523     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    5              0.000006   endtry
                            
                              " If a match is found setup match highlighting.
    5              0.000016   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom
                                if !g:matchparen_disable_cursor_hl
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[m_lnum, m_col]], 10))
                                endif
                                let w:paren_hl_on = 1
    5              0.000003   endif

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: C:\Program Files\Neovim\share\nvim\runtime\ftplugin.vim:15
Called 7 times
Total time:   0.172216
 Self time:   0.150805

count  total (s)   self (s)
    7              0.000075     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    7              0.000010     endif
                            
    7              0.000061     let s = expand("<amatch>")
    7              0.000023     if s != ""
    7              0.000081       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    7              0.000006       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   14              0.000097       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    7   0.171617   0.150205         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
   14              0.000039       endfor
    7              0.000009     endif

FUNCTION  <SNR>64_convert()
    Defined: ~\AppData\Local\nvim-data\lazy\lightline.vim\autoload\lightline.vim:329
Called 52 times
Total time:   0.000234
 Self time:   0.000234

count  total (s)   self (s)
   52              0.000103   if !has_key(s:lightline.component_expand, a:name)
   52              0.000106     return [[[a:name], 0, a:index, a:index]]
                              else
                                let type = get(s:lightline.component_type, a:name, a:index)
                                let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
                                return filter(map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
                              endif

FUNCTION  <SNR>42_Remove_Matches()
    Defined: C:\Program Files\Neovim\share/nvim/runtime/plugin/matchparen.vim:203
Called 56 times
Total time:   0.001139
 Self time:   0.001139

count  total (s)   self (s)
   56              0.000251   if exists('w:paren_hl_on') && w:paren_hl_on
                                while !empty(w:matchparen_ids)
                                  silent! call remove(w:matchparen_ids, 0)->matchdelete()
                                endwhile
                                let w:paren_hl_on = 0
   56              0.000038   endif

FUNCTION  lightline#update()
    Defined: ~\AppData\Local\nvim-data\lazy\lightline.vim\autoload\lightline.vim:13
Called 4 times
Total time:   0.008755
 Self time:   0.002650

count  total (s)   self (s)
    4   0.000087   0.000037   if s:skip() | return | endif
    4              0.000005   if s:_
                                if s:_ == 2 | return | endif
                                call lightline#init()
                                call lightline#colorscheme()
    4              0.000002   endif
    4              0.000010   if s:lightline.enable.statusline
    4              0.000016     let w = winnr()
    4   0.008470   0.002416     let s = winnr('$') == 1 && w > 0 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
   12              0.000016     for n in range(1, winnr('$'))
    8              0.000094       call setwinvar(n, '&statusline', s[n!=w])
   12              0.000006     endfor
    4              0.000002   endif

FUNCTION  <SNR>64_expand()
    Defined: ~\AppData\Local\nvim-data\lazy\lightline.vim\autoload\lightline.vim:341
Called 16 times
Total time:   0.002390
 Self time:   0.002156

count  total (s)   self (s)
   16              0.000019   let components = []
   16              0.000015   let expanded = []
   16              0.000013   let indices = []
   16              0.000013   let prevtype = ''
   16              0.000017   let previndex = -1
   16              0.000012   let xs = []
   16   0.000643   0.000409   call map(deepcopy(a:components), 'map(v:val, "extend(xs, s:convert(v:val, ''" . v:key . "''))")')
   68              0.000109   for [component, expand, type, index] in xs
   52              0.000055     if prevtype !=# type
   32              0.000114       for i in range(previndex + 1, max([previndex, index - 1]))
                                    call add(indices, string(i))
                                    call add(components, [])
                                    call add(expanded, [])
   32              0.000016       endfor
   32              0.000053       call add(indices, type)
   32              0.000042       call add(components, [])
   32              0.000038       call add(expanded, [])
   52              0.000027     endif
   52              0.000096     call extend(components[-1], component)
   52              0.000161     call extend(expanded[-1], repeat([expand], len(component)))
   52              0.000050     let prevtype = type
   52              0.000048     let previndex = index
   68              0.000037   endfor
   16              0.000065   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
                                call add(indices, string(i))
                                call add(components, [])
                                call add(expanded, [])
   16              0.000010   endfor
   16              0.000059   call add(indices, string(len(a:components)))
   16              0.000027   return [components, expanded, indices]

FUNCTION  <SNR>64_line()
    Defined: ~\AppData\Local\nvim-data\lazy\lightline.vim\autoload\lightline.vim:378
Called 8 times
Total time:   0.005928
 Self time:   0.002763

count  total (s)   self (s)
    8              0.000017   let _ = a:tabline ? '' : '%{lightline#link()}'
    8              0.000020   if s:lightline.palette == {}
                                call lightline#colorscheme()
    8              0.000003   endif
    8              0.000036   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
    8              0.000031   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
    8              0.000029   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
    8              0.000019   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
    8              0.000035   let ls = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
    8   0.001284   0.000064   let [lc, le, li] = s:expand(ls)
    8              0.000034   let rs = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
    8   0.001226   0.000056   let [rc, re, ri] = s:expand(rs)
   20              0.000027   for i in range(len(lc))
   12              0.000046     let _ .= '%#LightlineLeft_' . mode . '_' . li[i] . '#'
   36              0.000042     for j in range(len(lc[i]))
   24              0.000140       let x = le[i][j] ? lc[i][j] : has_key(f, lc[i][j]) ? s:func(f[lc[i][j]]) : get(c, lc[i][j], '')
   24              0.000156       let _ .= has_key(t, lc[i][j]) && t[lc[i][j]] ==# 'raw' || get(w, lc[i][j]) || le[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
   24              0.000052       if j < len(lc[i]) - 1 && s.left !=# ''
   12   0.000600   0.000109         let _ .= s:subseparator(lc[i][(j):], s.left, le[i][(j):])
   24              0.000011       endif
   36              0.000016     endfor
   12              0.000053     let _ .= '%#LightlineLeft_' . mode . '_' . li[i] . '_' . li[i + 1] . '#'
   12              0.000069     let _ .= i < l + len(lc) - len(ls) && li[i] < l || li[i] != li[i + 1] ? p.left : len(lc[i]) ? s.left : ''
   20              0.000011   endfor
    8              0.000021   let _ .= '%#LightlineMiddle_' . mode . '#%='
   28              0.000035   for i in range(len(rc) - 1, 0, -1)
   20              0.000092     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '_' . ri[i + 1] . '#'
   20              0.000107     let _ .= i < r + len(rc) - len(rs) && ri[i] < r || ri[i] != ri[i + 1] ? p.right : len(rc[i]) ? s.right : ''
   20              0.000074     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '#'
   48              0.000055     for j in range(len(rc[i]))
   28              0.000141       let x = re[i][j] ? rc[i][j] : has_key(f, rc[i][j]) ? s:func(f[rc[i][j]]) : get(c, rc[i][j], '')
   28              0.000191       let _ .= has_key(t, rc[i][j]) && t[rc[i][j]] ==# 'raw' || get(w, rc[i][j]) || re[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
   28              0.000051       if j < len(rc[i]) - 1 && s.right !=# ''
    8   0.000352   0.000067         let _ .= s:subseparator(rc[i][(j):], s.right, re[i][(j):])
   28              0.000012       endif
   48              0.000021     endfor
   28              0.000013   endfor
    8              0.000009   return _

FUNCTION  lightline#mode()
    Defined: ~\AppData\Local\nvim-data\lazy\lightline.vim\autoload\lightline.vim:217
Called 2 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    2              0.000008   return get(s:lightline.mode_map, mode(), '')

FUNCTION  <SNR>2_LoadIndent()
    Defined: C:\Program Files\Neovim\share\nvim\runtime\indent.vim:14
Called 7 times
Total time:   0.045458
 Self time:   0.045365

count  total (s)   self (s)
    7              0.000049     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    7              0.000005     endif
    7              0.000046     let s = expand("<amatch>")
    7              0.000017     if s != ""
    7              0.000015       if exists("b:did_indent")
                            	unlet b:did_indent
    7              0.000004       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   14              0.000075       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
    7   0.045098   0.045006         exe $'runtime! indent/{name}[.]{{vim,lua}}'
   14              0.000030       endfor
    7              0.000006     endif

FUNCTION  <SNR>64_skip()
    Defined: ~\AppData\Local\nvim-data\lazy\lightline.vim\autoload\lightline.vim:30
Called 4 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    4              0.000047     return !nvim_win_get_config(0).focusable

FUNCTION  lightline#link()
    Defined: ~\AppData\Local\nvim-data\lazy\lightline.vim\autoload\lightline.vim:222
Called 4 times
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
    4              0.000056   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
    4              0.000013   if s:mode ==# mode
    4              0.000006     return ''
                              endif
                              let s:mode = mode
                              if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
                              endif
                              let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
                              for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
                                for [i, t] in map(range(0, l), '[v:val, 0]') + types
                                  if i != l
                                    exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
                                  endif
                                  for [j, s] in map(range(0, l), '[v:val, 0]') + types
                                    if i + 1 == j || t || s && i != l
                                      exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
                                    endif
                                  endfor
                                endfor
                              endfor
                              exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
                              return ''

FUNCTION  <SNR>64_subseparator()
    Defined: ~\AppData\Local\nvim-data\lazy\lightline.vim\autoload\lightline.vim:300
Called 20 times
Total time:   0.000775
 Self time:   0.000775

count  total (s)   self (s)
   20              0.000088   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
   20              0.000494   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
   20              0.000162   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'

FUNCTION  GetLuaIndentIntern()
    Defined: C:\Program Files\Neovim\share\nvim\runtime\indent\lua.vim:40
Called 1 time
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
                              " Find a non-blank line above the current line.
    1              0.000008   let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
    1              0.000004   if prevlnum == 0
                                return 0
    1              0.000002   endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{', '('
    1              0.000005   let ind = indent(prevlnum)
    1              0.000004   let prevline = getline(prevlnum)
    1              0.000039   let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
    1              0.000002   if midx == -1
    1              0.000026     let midx = match(prevline, '\%({\|(\)\s*\%(--\%([^[].*\)\?\)\?$')
    1              0.000002     if midx == -1
    1              0.000014       let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
    1              0.000001     endif
    1              0.000001   endif
                            
    1              0.000002   if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
                                if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
                                  let ind = ind + shiftwidth()
                                endif
    1              0.000001   endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until, '}' and ')'
                              " This is the part that requires 'indentkeys'.
    1              0.000021   let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\|)\)')
    1              0.000005   if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
                                let ind = ind - shiftwidth()
    1              0.000001   endif
                            
    1              0.000002   return ind

FUNCTION  GetLuaIndent()
    Defined: C:\Program Files\Neovim\share\nvim\runtime\indent\lua.vim:30
Called 1 time
Total time:   0.000266
 Self time:   0.000073

count  total (s)   self (s)
    1              0.000019     let ignorecase_save = &ignorecase
    1              0.000004   try
    1   0.000030   0.000016     let &ignorecase = 0
    1   0.000192   0.000016     return GetLuaIndentIntern()
    1              0.000002   finally
    1   0.000012   0.000008     let &ignorecase = ignorecase_save
    1              0.000002   endtry

FUNCTION  <SNR>70_SynSet()
    Defined: C:\Program Files\Neovim\share\nvim\runtime\syntax\synload.vim:27
Called 8 times
Total time:   0.051293
 Self time:   0.051293

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    8              0.000036   syn clear
    8              0.000035   if exists("b:current_syntax")
                                unlet b:current_syntax
    8              0.000007   endif
                            
    8              0.000042   0verbose let s = expand("<amatch>")
    8              0.000017   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    8              0.000011   elseif s == "OFF"
                                let s = ""
    8              0.000003   endif
                            
    8              0.000008   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
   12              0.000072     for name in split(s, '\.')
    6              0.000033       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    6              0.050811         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
    6              0.000012       endif
   12              0.000010     endfor
    8              0.000005   endif

FUNCTION  lightline#statusline()
    Defined: ~\AppData\Local\nvim-data\lazy\lightline.vim\autoload\lightline.vim:313
Called 8 times
Total time:   0.006055
 Self time:   0.000127

count  total (s)   self (s)
    8              0.000028   if a:inactive && !has_key(s:highlight, 'inactive')
                                call lightline#highlight('inactive')
    8              0.000004   endif
    8   0.006000   0.000072   return s:line(0, a:inactive)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    7   0.172216   0.150805  <SNR>1_LoadFTPlugin()
    8   0.051293             <SNR>70_SynSet()
    7   0.045458   0.045365  <SNR>2_LoadIndent()
   52   0.015428   0.014368  <SNR>42_Highlight_Matching_Pair()
    4   0.008755   0.002650  lightline#update()
    8   0.006055   0.000127  lightline#statusline()
    8   0.005928   0.002763  <SNR>64_line()
   16   0.002390   0.002156  <SNR>64_expand()
   56   0.001139             <SNR>42_Remove_Matches()
   20   0.000775             <SNR>64_subseparator()
    1   0.000266   0.000073  GetLuaIndent()
   52   0.000234             <SNR>64_convert()
    1   0.000176             GetLuaIndentIntern()
    4   0.000086             lightline#link()
    4   0.000050             <SNR>64_skip()
    2   0.000010             lightline#mode()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    7   0.172216   0.150805  <SNR>1_LoadFTPlugin()
    8              0.051293  <SNR>70_SynSet()
    7   0.045458   0.045365  <SNR>2_LoadIndent()
   52   0.015428   0.014368  <SNR>42_Highlight_Matching_Pair()
    8   0.005928   0.002763  <SNR>64_line()
    4   0.008755   0.002650  lightline#update()
   16   0.002390   0.002156  <SNR>64_expand()
   56              0.001139  <SNR>42_Remove_Matches()
   20              0.000775  <SNR>64_subseparator()
   52              0.000234  <SNR>64_convert()
    1              0.000176  GetLuaIndentIntern()
    8   0.006055   0.000127  lightline#statusline()
    4              0.000086  lightline#link()
    1   0.000266   0.000073  GetLuaIndent()
    4              0.000050  <SNR>64_skip()
    2              0.000010  lightline#mode()

